# 一个大一写的简单的...解释器？

<p>
当时并没有怎么看过编译原理之类的东西...靠脑补的现在看起来非常原始了
</p>
<p>
使用 vs 2017 进行开发， Windows10环境;
详细报告参见report.pdf
</p>

## 以下是当年写的readme
<p>
基本算完成啦...不过估计还有很多bug没有发现（
感慨一下自己的工程能力和设计水平实在是太差了...很多地方都是凭感觉来做的很原始很不完善...
不过大概也算我自己写过的最大的项目了x
总共1700行左右...

整个项目由11个文件组成，除了brainfuck是单独的解释器部分，process和calculator共用文件，每个源文件都有相应的头文件。

以下三个部分是主要代码逻辑，其中主函数和词法分析、语法分析实现在process和calculator两个文件中；
process文件处理和计算表达式，同时对于在表达式中的函数和变量完成相应的寻址工作；
calculator文件负责语句块的分片、每个语句的处理；完成选择循环赋值三种工作，同时提供函数定义功能；主函数的入口也在其中，去调用语句块处理函数；
functions文件实现了相应的c语言函数调用接口，系统自带命令函数，以及自定义函数的处理过程；自定义函数的处理在一个func_函数中完成，使用真实函数来模拟；

接下来的是链表、哈希表、栈三种数据结构；
栈的使用是用来完成语句块和语句处理中的括号匹配，以及前缀表达式转中缀表达式和计算；
哈希表用来实现变量作用域，在运行过程中哈希表由链表串联，实现了变量作用域栈，并在函数初始化和结束时生成和释放；
链表主要有两个功能，在运行过程中实现变量的自动分配空间、释放空间和存储，同时串联哈希表；
</p>

# 测试样例：
- 1
  answer = 1.000000



- 1+2*3
answer = 7.000000



 - 1 - 2 / 3 
answer = 0.333333



- (1+3*4/(8/2))+1.9
answer = 5.900000


- x=3;y=4;(1+x*y/(8/2))+1.9;
x =3; y= 4;(1+  x* y/ (8 /2))+1.9;
:
x =3; 
y=
 4;
(1+  x
* y
/ (8 
/2))+1.9;
:
answer = 5.900000



- sin(1)+cos(2)*sqrt(4)+pow(5,6)
sin( 1)+cos( 2)* sqrt( 4 )+pow( 5 , 6 )
mid[]:  0.841471  -0.416147  2.000000  * + 15625.000000  +
answer = 15625.009177



- 2/0
ERROR: dividing number can not be zero



- x=1;sum=0;while(x<=100){sum=sum+x;x=x+1;};sum;
answer = 5050.000000

- mid[]:  1.000000  1.000000  +
mid[]:  3.000000  2.000000  +
mid[]:  5.000000
answer = 5.000000



- define(max){ if(a>b){return a;}; return b;};
a=3; b=4;answer = 4.000000max(a,b);
a=4; b=7;max(a b);answer = 7.000000;
a=3642; b=17.13;max( a b );answer = 3642.000000;



- :
a=1;
b=0;
c=0;
while(a<=100){if(a%2==0){b=b+a;};if(a%2>0){c=c+a;};a=a+1;};
:
or type:
:
a=1;
b=0;
c=0;
while(a<=100){
if(a%2==0){
b=b+a;
};
if(a%2>0){
c=c+a;
};
a=a+1;
};
:
or:
 :
define(sum){a=1;
b=0;
c=0;
while(a<=100){
if(a%2==0){
b=b+a;
};
if(a%2>0){
c=c+a;
};
a=a+1;
};
a;b;c;};
:
sum();
a
answer = 101.000000
b
answer = 2550.000000
c
answer = 2500.000000



- defarray(a,10);
a
a is an array:
 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
i=0;
while(i<10){a[i]=i;i=i+1;};
a
a is an array:
 0.000000 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.000000


- 2/%43
calculate error!



